
# BRIUKHANOV-N.A

Git - открытая распределенная система контроля версий. 

Vcs - Version Control System 
Repository - data base of linked states working copy 
Репозиторий - хранилище данных
Version Control System - программное обеспечение для облегчения работы с изменяющей инфляцией 
Commit - объект, в котором содержится описание изменений, которые были внесены в код 
Простая система это папки с указанием версии
Недостатки : неудобно структурировать, много месте 
Git - сохраняет только изменения - экономие места. Несколько разработчиков - работа в команде, откатиться на прошлую версию 

1 поколение - локальные : + независимо от серверов : - нет команды 

2 поколение - централизованное :+  работа в команде, отслеживание действий, администрирование центральную Vcs  : - всё данные хранятся только на одном сервере, нужен хороший интернет 

3 поколение - работа компании теперь не зависит от работы сервера. Если сервер отключиться, то каждый сотрудник предложит работу ч локальной копией ,не зависим от интернета : - сложное администрирование, нет отслеживания в реальном времени 
Делиться кодом 

Линус Торвальдс создал git 

Git - открытая распределенная система контроля версий. 

Vcs - Version Control System 
Repository - data base of linked states working copy 
Репозиторий - хранилище данных
Version Control System - программное обеспечение для облегчения работы с изменяющей инфляцией 
Commit - объект, в котором содержится описание изменений, которые были внесены в код 
Простая система это папки с указанием версии
Недостатки : неудобно структурировать, много месте 
Git - сохраняет только изменения - экономие места. Несколько разработчиков - работа в команде, откатиться на прошлую версию 

1 поколение - локальные : + независимо от серверов : - нет команды 

2 поколение - централизованное :+  работа в команде, отслеживание действий, администрирование центральную Vcs  : - всё данные хранятся только на одном сервере, нужен хороший интернет 

3 поколение - работа компании теперь не зависит от работы сервера. Если сервер отключиться, то каждый сотрудник предложит работу ч локальной копией ,не зависим от интернета : - сложное администрирование, нет отслеживания в реальном времени 
Делиться кодом 

Линус Торвальдс создал git 

Er диаграммы - сущность связь 

Концептуальная связь и физическая 
Отображаются типы данные
Обязательные поля, необязательные поля
На английском 

Концептуальный и физические диаграммы

Er диаграммы это или диаграммы сущность связь в базе данных это таблица

Таблица с линиями линии это отношения

Физическая - это та диаграммы которую создают автоматически

Физическая диаграмма

Генерируется автоматически

Отображаются типы данных

Имеет тип данных есть обязательность  и необезательность полей

Всё на англе

Концептуальная диаграмма

На русском

Создаётся  вручную

Нет типов данных

Нет обязательность и необезательность заполнения полей


09.09.22

Созданте папки 
Создание папки - / 
Точки не используется 
Не бывает пустых папокпапок
Ветка - подвижный указатель 
master - main основаной, создаётся по-умолчанию
Realese - выпуск продукта
Develop - разработка 
Feature - фишка 
Feature 
Программа - последовательное описание (на формальном языке) процесса обработки информации для решения какой либо задачи на ЭВМ

Если исполнитель не может выпонить команду, то он прекращает работу с ошибкой 

Компилятор - язык исполнителя для обычного человека очень сложно читать и понимать

Компиляция - процесс перевода исходного кода, кода программы на формальном языке в программу. 
Среда разработки - инструмент для написания исходного кода программы. 
Если компилятор не может перевести исходный код программы не язык исполнителя. 
Структура :
1.подготовка к работе 
2.объявление и инициализации переменных для работы 
3.получение данных 
4.проверка данных
5.выполнение действий для решений задачи 
6.вывод вывод задачи 
7.заверление работы 

Подготовка к работе : подключение модулей, описание точки входа в программу, подготовка к работе 
Модули : это готовые части прогоаммы, которые можно использовать при решении задач 

Ввод / вывод 
Для вывода данных в консоль нужно написать программу. 
‌Решение : команды для выполнения арфитическиз действий, условные конструкции, циклические конструкци



22.09.2022
Бывают языки интерпретируемы и компилируемые

Компиоятор - в машинный код и после этого происходит запуск программ: быстрота
Минусы : сборка идёт на конкретном устройстве(плохая переносимость) 

Итопоетатор - объеденяет сборку и запуск, бывают виртуальные машины :плюсы,- можно запускать на нескольких платформах 
Минусы : застоачиваются ресурсы, долгий 

Компиляция : с++ 
Интопретатор : python 
Ide  для питона - скачать сам питон 
Благодаря степику : получить лицензию 
Скачать pycharm 


+ работает без интернета 
-много весит
Jypyter Notebook/ google colaboratory
Используют сторонние сервера 
Недостаток подключения других 
Временное хранилище файлов
Проблема работа с видео и с камерой
1.убр



23.09.22
1.информация представлена в виде 0,1 
2.по этому информацию в степенях 2 (0, 1) 
2 в 1 степени = 1 бит
2 в 8 = 264 бит 
Чтобы записать целое число мы можем использовать количество символов равной 2 В 32 бита = 4 байта 
Longint 
Short int 


Алгоритмы и структура данных 
   
 Определение кратчайшего пути, выбор необходимого подмножества объектов, поиск наилучшего совпадения строк — каждую из этих задач можно решить несколькими разными способами. Все они дадут одинаковый результат, но один вариант окажется самым простым в реализации; другой — более эффективным; а третий — максимально быстрым, но при этом будет использовать много оперативной памяти.
   Алгоритм — это инструкция, которая описывает порядок выполнения действий. Например, один из вариантов алгоритма поиска минимального элемента в массиве можно записать с помощью такого псевдокода

функция get_minimal_element(input_list):
    minimal_element = None
    для element из input_list:
        если minimal_element is None ИЛИ element < minimal_element тогда:
            minimal_element = element
    вернуть minimal_element 

  Алгоритмы описывают то, как мы преобразуем данные, чтобы получить требуемый результат. С ними тесно связаны структуры данных, в которых эти данные хранятся. Разные структуры хранят данные по-разному и из-за этого у них возникают интересные свойства.
 
Итак, вот что мы можем сказать про эти «структуры данных»:
Библиотека, в которой книги расставлены в алфавитном порядке: быстрый поиск, но добавление новых книг в некоторых случаях может быть медленным.
Шкаф, в котором книги стоят без определённого порядка: медленный поиск, зато добавлять новые книги можно быстро.
   Временной ряд — это набор измерений некоторой величины во времени. Значения максимальной дневной температуры на Марсе по данным марсохода Curiosity — это тоже временной ряд. Можно построить график, на котором по вертикали будет указана температура в градусах Цельсия, а по горизонтали — дни миссии Curiosity.
Метод скользящего среднего
Метод заключается в том, что создаётся новый массив данных, и в нём значение каждой точки высчитывается как среднее арифметическое предыдущих K значений из исходного набора.
То есть для каждой секунды посчитаем среднее арифметическое от количества запросов за предыдущие K|секунд. Этот интервал K будем называть «окном сглаживания». На каждой итерации он смещается, «скользит» — отсюда и название метода.
Например, если данные по нагрузке на сайт для 7 секунд будут такие: [4, 3, 8, 1, 5, 6, 3], а K=3 то сглаженные значения получатся следующими: [5, 4, 4.67, 4, 4.67]
  Самое очевидное и простое решение какой-либо задачи называется «наивный алгоритм» — это устоявшийся термин.
 На вход функция будет принимать массив с данными timeseries и размер окна сглаживания K.
функция скользящее_среднее(timeseries, K):
    result = []  # Пустой массив.
    для begin_index из [0 .. len(timeseries) - K]:
        end_index = begin_index + K
        # Просматриваем окно шириной K.
        current_sum = 0
        для каждого v из timeseries[begin_index .. end_index):
            current_sum += v
        current_avg = current_sum / K
        result.добавить(current_avg)
    вернуть result 

   Передадим в функцию скользящее_среднее() данные и окно сглаживания со значением K = 3600. Функция вернёт массив result, на основе которого построим сглаженный график:

О пользе полуинтервалов
В псевдокоде применено обозначение [a..b) для аналогии с полуинтервалами.
Полуинтервалом [a;b) в математике обозначают такое множество чисел x, где a≤x<b. Программисты обычно оперируют полу интервалами при работе с индексами массивов. В коде удобно исключать правую границу b, потому что:
Элементы в массиве длины N нумеруются индексами от 0 до N-1: 0,1,2,…,N−1. Для каждого элемента x_i выполняется условие 0≤i<N. Индексы этого массива красиво записываются полуинтервалом [0;N).
Если из массива длины N нам необходимо взять первые k элементов, то этот массив можно естественно разбить на два подмассива — с индексами [0;k) и [k;N) соответственно.
Легко вычисляется длина полуинтервала (то есть размер подмассива) [a;b) — это просто разность b−a.
Запись [a;a) валидна и обозначает пустой полуинтервал (то есть пустой подмассив).
Скорость работы наивного алгоритма
Давайте посмотрим, насколько эффективно работает функция скользящее_среднее().
Пусть длина входного массива будет равна N, а окно сглаживания — K. В коде есть два вложенных цикла:
внешний выполняет ровно N−K+1 итераций;
внутренний выполняет K итераций на каждой из N−K+1 итераций внешнего цикла.
Получается, общее число операций в циклах будет равно N*K-K^2+K. Поскольку в нашем случае N сильно больше K, частью (-K^2+K) в этом выражении можно пренебречь и считать число операций примерно равным N×K.
Если величина X сильно больше величины Y, то это можно обозначить так: X>>Y. Можно также сказать, что Y сильно меньше X с помощью обозначения Y<<X. Это значит, что Y настолько мало по сравнению с X, что в задаче можно считать величину Y/X равной нулю. Из этого, в частности, следует, что X−Y приблизительно равно X.
 
Ускорение скользящего среднего
Оптимизация алгоритма
Рассмотрим итерацию i+1. На предыдущей итерации i мы вычислили значение переменной current_sum как сумму элементов от i до i+K−1 включительно:

current_sum = timeseries[i] + timeseries[i+1] + ... + timeseries[i+K-1]

На текущей итерации i+1 значение current_sum считается как сумма элементов от i+1 до i+K включительно:

current_sum = timeseries[i+1] + ... + timeseries[i+K-1] + timeseries[i+K]

Сумма элементов с i+1 по i+K−1 пересчиталась повторно: значит, на последовательных итерациях значения current_sum отличаются только за счёт элементов i+K и i.

 
 

# Пусть в current_sum записана сумма на прошлой итерации i.
# Вычислим её значение для текущей итерации i+1.
current_sum -= timeseries[i]
current_sum += timeseries[i+K] 

Такой пересчёт возможен на любой итерации, кроме первой: на ней значение current_sum придётся посчитать честно, просуммировав все элементы с 0 по K−1.

Оптимизированный алгоритм:
функция скользящее_среднее(timeseries, K):
    result = []  # Пустой массив.
    # Первый раз вычисляем значение честно и сохраняем результат.
    current_sum = сумма элементов timeseries[0..K)
    result.добавить(current_sum / K)
    для i из [0 .. len(timeseries) - K):
        current_sum -= timeseries[i]
        current_sum += timeseries[i+K]
        current_avg = current_sum / K
        result.добавить(current_avg)
    вернуть result
Метод двух указателей
«Метод двух указателей». В алгоритме действительно есть два указателя: они задают начало и конец рассматриваемого интервала. Чтобы пересчитать среднее арифметическое, мы:
сначала изменяем его исходя из тех значений, на которые ссылаются указатели,
а потом эти указатели смещаем.
Наивный алгоритм
Именно с наивного алгоритма рекомендуется начинать решение любой задачи, в том числе и на собеседованиях. Если от вас захотят получить более эффективное решение — вам скажут об этом явно.
Квадратичная функция — это функция вида f(x) = ax^2+bx+c где a,b,с — это числа. Название функции связано с тем, что главный элемент такой суммы — это x^2 с некоторым коэффициентом. Главный он потому, что при больших x остальные элементы окажутся сильно меньше и не сыграют заметной роли; в итоге значение функции будет приблизительно равно ax^2.
В рассуждении выше N^2/4 — это квадратичная функция с коэффициентами 
a=1/4, b=0, b=0, c=0.


Регулярные выражения в Python.
Что такое регулярное выражение?
   Регулярное выражение (Regular Expression, RegEx) — это мощный, гибкий и эффективный инструмент для сопоставления текста на основе заранее определенного шаблона.

1. Data Mining: регулярное выражение — лучший инструмент для интеллектуального анализа данных. Он эффективно идентифицирует текст (строку, подстроку) в куче текста, проверяя его по заранее заданному шаблону. Некоторые распространенные сценарии — определение адреса электронной почты, URL-адреса или телефона из кучи текста.

2. Data Validation (Проверка данных): регулярное выражение может идеально подойти для таких задач, как проверка данных. Он может включать в себя широкий спектр процессов проверки путем определения различных наборов шаблонов. Вот несколько примеров: проверка номеров телефонов, электронной почты и т.д.
   Модуль Re (import re) — операции с регулярными выражениями.
   Основная функция модуля re — предложить поиск, в котором используются регулярное выражение и строка. Здесь он либо возвращает первое совпадение, либо ничего. Модуль re вызывает исключение re.error, если ошибка возникает при компиляции или использовании регулярного выражения.
Команда для импорта модуля re:
   Краткое описание синтаксиса RegEx на примере с Email
Пример регулярного выражения для проверки email с пометкой каждого компонента:



Еще один пример с почтой:

Описание некоторых общих компонентов регулярных выражений:
Символ + в регулярном выражении означает «сопоставить предыдущий символ один или несколько раз». Например, ab+c соответствует «abc», «abbc», «abbbc», но не соответствует «ac» . Знак плюс, используемый в регулярном выражении, называется Клини плюс в честь математика Стивена Клини (1909–1994), который ввел эту концепцию.
Символ * в регулярном выражении означает «сопоставить предыдущий символ ноль или более раз». Например, ab*c соответствует «abc», «abbc», «abbbc» и «ac». Это называется звездой Клини.
Знак вопроса ? указывает на 0 или 1 вхождение предыдущего элемента. Например, colou?r соответствует как «color», так и «colour».
Точка соответствует любому одиночному символу (кроме символа новой строки). Например, a.c соответствует «abc», «adc», «aec» и т.д. Если мы хотим сопоставить несколько символов перед буквой «c», мы бы просто использовали звездочку * следующим образом: a.*c и это будет соответствовать «a bdefgh c».
[a-z]: очень полезно, так как определяет диапазон возможных значений — относится ко всем строчным буквам алфавита от a до z. Мы можем сделать то же самое для букв верхнего регистра и всех положительных чисел, подобных этому [A-Z] & [0-9].
^: Соответствует начальной позиции любой строки.
[^b]at соответствует всем строкам, за .at исключением «bat». Поэтому при использовании ^ в квадратных скобках следующая буква исключается.
^[hc]at соответствует «hat» и «cat», но только в начале строки.
\ Backspace экранирует точку, поэтому наше регулярное выражение не считает, что это часть наших квантификаторов, как определено выше. Нам нужно, чтобы точка была буквально частью нашего шаблона, поскольку она находится в нашем поисковом шаблоне.
   RegEx в Python
   Регулярные выражения — это, по сути, крошечный узкоспециализированный язык программирования, встроенный в Python и доступный через модуль re.
   Используя этот небольшой язык, вы указываете правила для набора возможных строк, которые вы хотите сопоставить:
этот набор может содержать английские предложения,
или адреса электронной почты,
или команды TeX,
и т.д.
Вводный пример RegEx на Python
Пример — Проверим строку, что она начинается с ‘The’ и заканчивается ‘Spain’:
import re

#Check if the string starts with "The" and ends with "Spain":

txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)

if x:
  print("YES! We have a match!")
else:
  print("No match")
Результат:
YES! We have a match!

Функции RegEx
Модуль re предоставляет набор функций/методов, которые позволяют нам искать строку по совпадению:
findall() — Возвращает список, содержащий все совпадения
search() — Возвращает объект Match, если где-либо в строке есть совпадение
split() — Возвращает список, в котором строка была разделена при каждом совпадении
sub() — Заменяет одно или несколько совпадений строкой
subn() — Делает то же самое, что и sub(), но возвращает новую строку и количество замен
match() — Ищет совпадение с начала строки
finditer() — Ищет все совпадения с pattern, возвращает итератор
compile() — Компилирует regular expression, на выходе получаем объект, к которому затем можно применять все перечисленные функции
fullmatch() — Проверяет, что вся строка соответствует описанному регулярному выражению
flags (флаги) — Указываются в функциях, влияют на поведение регулярного выражения
Metacharacters (Метасимволы)
Метасимволы — это символы со специальным значением:

Special Sequences RegEx (Специальные последовательности)
Специальная последовательность — это когда за символом \ следует один из символов в списке ниже, которая имеет особое значение:


   Sets (Наборы)
Set (Набор) — это набор символов внутри пары квадратных скобок [] со специальным значением:


Символ \ — бэкслеш в Python RegEx
  Регулярные выражения используют символ обратной косой черты (‘\’) для обозначения специальных форм или для разрешения использования специальных символов без обращения к их особому значению. Это противоречит тому, что Python использует тот же символ для той же цели в строковых литералах.
   Результирующая строка, которую необходимо передать, re.compile() должна быть \\section. Однако, чтобы выразить это как строковый литерал Python, обе обратные косые черты должны быть снова экранированы.
\section Текстовая строка для сопоставления  
\\section Экранированная обратная косая черта для re.compile() 
"\\\\section" Экранированные символы обратной косой черты для строкового литерала

Функция findall()
Определение функции
Функция findall() возвращает список, содержащий все совпадения.
Модуль findall() используется для поиска «всех» вхождений, соответствующих заданному шаблону. Напротив, модуль search() вернет только первое вхождение, соответствующее указанному шаблону. findall() перебирает все строки файла и возвращает все непересекающиеся совпадения шаблона за один шаг.
Синтаксис
re.findall(pattern, string, flags=0)
Функция search()
Определение функции
Функция search() будет искать шаблон регулярного выражения и возвращать первое вхождение. В отличие от Python match(), он проверяет все строки входной строки. Функция Python search() возвращает объект соответствия, когда шаблон найден, и «ноль», если шаблон не найден.
Синтаксис
re.search(pattern, string, flags=0)
Функция split()
Определение функции
Функция split() работает аналогично методу split в строках, но в функции re.split можно использовать регулярные выражения, а значит, разделять строку на части по более сложным условиям.
Синтаксис
re.split(pattern, string, maxsplit=0, flags=0)
Функция sub()
Определение функции
Функция re.sub работает аналогично методу replace в строках. Но в функции re.sub можно использовать регулярные выражения, а значит, делать замены по более сложным условиям.
Синтаксис
re.sub(pattern, repl, string, count=0, flags=0)
Функция subn()
Определение функции
Функция subn() аналогична sub(), но возвращает новую строку и количество произведенных замен.
Синтаксис
re.subn(pattern, repl, string, count=0, flags=0)
Функция match()
Определение функции
Функция re.match() re в Python будет искать шаблон регулярного выражения только в начале строки. Функция match() возвращает объект соответствия, если часть начала строки подпадает под шаблон, иначе функция вернет None.
Синтаксис
re.match(pattern, string, flags=0)
Функция fullmatch()
Определение функции
Функция re.fullmatch() вернет объект сопоставления, если вся исходная строка соответствует шаблону Regular Expression.
Синтаксис
re.fullmatch(pattern, string, flags=0)
Функция compile()
Использование компилированного выражения может ускорить обработку, и, как правило, такой вариант удобно использовать, так как в программе разделяется создание регулярного выражения и его использование. Кроме того, при использовании функции re.compile создается объект RegexObject, у которого есть несколько дополнительных возможностей, которых нет в объекте MatchObject.

Синтаксис
re.compile(pattern, flags=0)
Функция finditer()
Определение функции
Метод finditer() используется для поиска всех непересекающихся совпадений в шаблоне и возвращает итератор с объектами Match (finditer возвращает итератор даже в том случае, когда совпадение не найдено). Функция finditer отлично подходит для обработки тех команд, вывод которых отображается столбцами.
Синтаксис
re.finditer(pattern, string, flags=0)
Match Object
Определение
Match Object — это объект, содержащий информацию о поиске и результате.
Объект Match имеет свойства и методы, используемые для получения информации о поиске и результате:
.span() возвращает кортеж, содержащий начальную и конечную позиции совпадения.
.string возвращает строку, переданную в функцию,
.group() возвращает часть строки, в которой произошло совпадение

Регулярные выражения C#

   Основная функциональность регулярных выражений в .NET сосредоточена в пространстве имен System.Text.RegularExpressions. А центральным классом при работе с регулярными выражениями является класс Regex.
   Например, у нас есть некоторый текст и нам надо найти в нем все словоформы какого-нибудь слова. С классом Regex это сделать очень просто:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
using System.Text.RegularExpressions;
 
string s = "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа";
Regex regex = new Regex(@"туп(\w*)");
MatchCollection matches = regex.Matches(s);
if (matches.Count > 0)
{
    foreach (Match match in matches)
        Console.WriteLine(match.Value);
}
else
{
    Console.WriteLine("Совпадений не найдено");
}



Параметр RegexOptions
Класс Regex имеет ряд конструкторов, позволяющих выполнить начальную инициализацию
объекта. Две версии конструкторов в качестве одного из параметров принимают перечисление RegexOptions. Некоторые из значений, принимаемых данным перечислением:
Compiled: при установке этого значения регулярное выражение компилируется в сборку, что обеспечивает более быстрое выполнение
CultureInvariant: при установке этого значения будут игнорироваться региональные различия
IgnoreCase: при установке этого значения будет игнорироваться регистр
IgnorePatternWhitespace: удаляет из строки пробелы и разрешает комментарии, начинающиеся со знака #
Multiline: указывает, что текст надо рассматривать в многострочном режиме. При таком режиме символы "^" и "$" совпадают, соответственно, с началом и концом любой строки, а не с началом и концом всего текста
RightToLeft: приписывает читать строку справа налево
Singleline: при данном режиме символ "." соответствует любому символу, в том числе последовательности "\n", которая осуществляет переход на следующую строку
Например:


Regex regex = new Regex(@"туп(\w*)", RegexOptions.IgnoreCase);

При необходимости можно установить несколько параметров:


Regex regex = new Regex(@"туп(\w*)", RegexOptions.Compiled | RegexOptions.IgnoreCase);

Синтаксис регулярных выражений
Рассмотрим вкратце некоторые элементы синтаксиса регулярных выражений:
^: соответствие должно начинаться в начале строки (например, выражение @"^пр\w*" соответствует слову "привет" в строке "привет мир")
$: конец строки (например, выражение @"\w*ир$" соответствует слову "мир" в строке "привет мир", так как часть "ир" находится в самом конце)
.: знак точки определяет любой одиночный символ (например, выражение "м.р" соответствует слову "мир" или "мор")
*: предыдущий символ повторяется 0 и более раз
+: предыдущий символ повторяется 1 и более раз
?: предыдущий символ повторяется 0 или 1 раз
\s: соответствует любому пробельному символу
\S: соответствует любому символу, не являющемуся пробелом
\w: соответствует любому алфавитно-цифровому символу
\W: соответствует любому не алфавитно-цифровому символу
\d: соответствует любой десятичной цифре
\D : соответствует любому символу, не являющемуся десятичной цифрой

1 Теперь посмотрим на некоторые примеры использования. Возьмем первый пример с скороговоркой "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа" и найдем в ней все слова, где встречается корень "губ":
1
2
string s = "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа";
Regex regex = new Regex(@"\w*губ\w*");

Так как выражение \w* соответствует любой последовательности алфавитно-цифровых символов любой длины, то данное выражение найдет все слова, содержащие корень "губ".
2 простенький пример - нахождение телефонного номера в формате 111-111-1111:
1
2
string s = "456-435-2318";
Regex regex = new Regex(@"\d{3}-\d{3}-\d{4}");

 Если мы точно знаем, сколько определенных символов должно быть, то мы можем явным образом указать их количество в фигурных скобках: \d{3} - то есть в данном случае три цифры.
3 Мы можем не только задать поиск по определенным типам символов - пробелы, цифры, но и задать конкретные символы, которые должны входить в регулярное выражение. Например, перепишем пример с номером телефона и явно укажем, какие символы там должны быть:
1
2
string s = "456-435-2318";
Regex regex = new Regex("[0-9]{3}-[0-9]{3}-[0-9]{4}");

В квадратных скобках задается диапазон символов, которые должны в данном месте встречаться. В итоге данный и предыдущий шаблоны телефонного номера будут эквивалентны.
Также можно задать диапазон для алфавитных символов: Regex regex = new Regex("[a-v]{5}"); - данное выражение будет соответствовать любому сочетанию пяти символов, в котором все символы находятся в диапазоне от a до v.
Можно также указать отдельные значения: Regex regex = new Regex(@"[2]*-[0-9]{3}-\d{4}");. Это выражение будет соответствовать, например, такому номеру телефона "222-222-2222" (так как первые числа двойки)
4 С помощью операции | можно задать альтернативные символы, например:
1
Regex regex = new Regex(@"(2|3){3}-[0-9]{3}-\d{4}");

То есть первые три цифры могут содержать только двойки или тройки. Такой шаблон будет соответствовать, например, строкам "222-222-2222" и "323-435-2318". А вот строка "235-435-2318" уже не подпадает под шаблон, так как одной из трех первых цифр является цифра 5.
5 Итак, у нас такие символы, как *, + и ряд других используются в качестве специальных символов. И возникает вопрос, а что делать, если нам надо найти, строки, где содержится точка, звездочка или какой-то другой специальный символ? В этом случае нам надо просто экранировать эти символы слешем:
1
2
Regex regex = new Regex(@"(2|3){3}\.[0-9]{3}\.\d{4}");
// этому выражению будет соответствовать строка "222.222.2222"

Проверка на соответствие строки формату

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
using System.Text.RegularExpressions;
 
string pattern = @"^(?("")(""[^""]+?""@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))" +
                @"(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-\w]*[0-9a-z]*\.)+[a-z0-9]{2,17}))$";
var data = new string[]
{
    "tom@gmail.com",
    "+12345678999",
    "bob@yahoo.com",
    "+13435465566",
    "sam@yandex.ru",
    "+43743989393"
};
 
Console.WriteLine("Email List");
for(int i = 0; i < data.Length; i++)
{
    if (Regex.IsMatch(data[i], pattern, RegexOptions.IgnoreCase))
    {
        Console.WriteLine(data[i]);
    }
}

Переменная pattern задает регулярное выражение для проверки адреса электронной почты. Данное выражение предлагает нам Microsoft на страницах msdn.
Далее в цикле мы проходим по массиву строк и определяем, какие строки соответствуют этому шаблону, то есть представляют валидный адрес электронной почты. Для проверки соответствия строки шаблону используется метод IsMatch: Regex.IsMatch(data[i], pattern, RegexOptions.IgnoreCase). Последний параметр указывает, что регистр можно игнорировать. И если строка соответствует шаблону, то метод возвращает true.
Замена и метод Replace
Класс Regex имеет метод Replace, который позволяет заменить строку, соответствующую регулярному выражению, другой строкой:







1 string text = "Мама  мыла  раму. ";
2 string pattern = @"\s+";
3 string target = " ";
4 Regex regex = new Regex(pattern);
5 string result = regex.Replace(text, target);
6 Console.WriteLine(result);

Данная версия метода Replace принимает два параметра: строку с текстом, где надо выполнить замену, и сама строка замены. Так как в качестве шаблона выбрано выражение "\s+ (то есть наличие одного и более пробелов), метод Replace проходит по всему тексту и заменяет несколько подряд идущих пробелов ординарными.
Другой пример - на вход подается номер телефона в произвольном формате, и мы хотим оставить в нем только цифры:







1 string phoneNumber = "+1(876)-234-12-98";
2 string pattern = @"\D";
3 string target = "";
4 Regex regex = new Regex(pattern);
5 string result = regex.Replace(phoneNumber, target);
6 Console.WriteLine(result);  // 18762341298

В данном случае шаблон "\D" представляет любой символ, который не является цифрой. Любой такой символ заменяется на пустую строку "", то есть в итоге из строки "+1(876)-234-12-98" мы получим строку "18762341298".
